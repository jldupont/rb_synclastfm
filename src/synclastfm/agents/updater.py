"""
    Updater module

    1) if "rating" is 0.0
          if "love" is True
             update rating
             
    2) take last.fm's playcount and
       update local playcount of track

    MESSAGES IN:
    - "track_entry"
    - "rb_shell"
    - "user_track_info"
    - "mb_entry"
    

    @author: jldupont
"""
import rhythmdb #@UnresolvedImport

import gobject #@UnresolvedImport
from synclastfm.system.bus import Bus


class Updater(gobject.GObject): #@UndefinedVariable
    """
    Updates various properties
    """
    def __init__(self):
        gobject.GObject.__init__(self) #@UndefinedVariable
        self._shell=None
        self._db=None
        
        Bus.add_emission_hook("mb_entry",        self.on_mb_entry)
        Bus.add_emission_hook("track_entry",     self.on_track_entry)
        Bus.add_emission_hook("user_track_info", self.on_user_track_info)
        Bus.add_emission_hook("rb_shell",        self.on_rb_shell)
        
    def on_rb_shell(self, _signal, rbobjects):
        """
        Grab RB objects references (shell, db, player)
        
        GObject handler
        """
        self._robjects=rbobjects
        self._db=self._robjects.db
        return True
        
    def on_track_entry(self, _, trackWrapper):
        """
        Note: track_entry is defined in "Finder"
        """
        te=trackWrapper.track_entry
        dbe=trackWrapper.db_entry
        
        ## If Finder didn't find an entry in the database,
        ## we can't do much at this point
        if dbe is None:
            return True
        
        try:
            playcount=te["playcount"]
            self._db.set(dbe, rhythmdb.PROP_PLAY_COUNT, playcount)
            self._db.commit()
        except:
            print "ERROR: updating 'playcount' for track"
        
        return True
        
    def on_mb_entry(self, _, mbe):
        """
        Message handler for the 'mb_entry' message
        generated by the MB Agent
        """
        
        
        try:    rbid=long(mbe.rbid)
        except: 
            print "mb.on_mb_entry: rbid is not an integer!"
            return True
        
        print "mb.on_mb_entry.0: rbid: %s" % rbid
        
        try:
            print "mb.on_mb_entry.1"
            s1=(rhythmdb.QUERY_PROP_EQUALS, rhythmdb.PROP_ENTRY_ID, rbid)
            print "mb.on_mb_entry.2"
            query = self._db.query_new()
            print "mb.on_mb_entry.3"
            self._db.query_append(query, s1)
            print "mb.on_mb_entry.4"
            query_model = self._db.query_model_new_empty()
            print "mb.on_mb_entry.5"
            self._db.do_full_query_parsed(query_model, query)
            print "mb.on_mb_entry.6"
        except Exception,e:
            print "updater.on_mb_entry: EXCEPTION: %s" % e
            return True
        
        dbe=None
        for e in query_model:
            dbe=e[0]
            print "updater.on_mb_entry: FOUND: id(%s)" % rbid            
            break  ## not elegant but it works
        
        if dbe is None:
            print "*** updater.on_mb_entry: NOT FOUND: id(%s)" % rbid
            return True
        
        try:     track_mbid=str(mbe.details["track_mbid"])
        except:  track_mbid=None
        
        ## If we don't have a UUID for this track,
        ##  then there ain't much we can do...
        if track_mbid is None:
            print "mb.on_mb_entry: track_mbid not set"
            return True
        
        self._db.set(dbe, rhythmdb.PROP_MUSICBRAINZ_TRACKID, track_mbid)
        self._db.commit()
        return True
        
        
    def on_user_track_info(self, _signal, track):
        """
        GObject handler
        
        track.details : dict with extracted information from track.entry
        track.entry: an RB DB entry
        track.lastfm_info
        
        @param track: a Track object instance 
        """
        
        ## These are always guaranteed to be since
        ## they originate from RB
        rating=track.details["rating"]
        
        ## These might be missing
        try:    love=int(track.lastfm_info.get("track.userloved", 0))
        except: love=0
        try:    lfmpc=int(track.lastfm_info.get("track.userplaycount", 0))
        except: lfmpc=0
        
        #print ">> rating(%s) love(%s) local playcount(%s) lastfm playcount(%s)" % (rating, love, lpc, lfmpc)
        
        try:    track_mbid=str(track.lastfm_info.get("track.mbid", ""))
        except: track_mbid=""
       
        try:
            changed=False
        
            ## Update the track's mbid if we can
            if track_mbid != "":
                self._db.set(track.entry, rhythmdb.PROP_MUSICBRAINZ_TRACKID, track_mbid)
                changed=True
                #print "% track_mbid: %s" % track_mbid
                
            
            ## Only update local "playcount" if we have a meaningful 
            ## playcount from Last.fm
            if lfmpc > 0:
                self._db.set(track.entry, rhythmdb.PROP_PLAY_COUNT, lfmpc)
                changed=True
                #print ">> Updating playcount to: %s" % lfmpc
            
            ## Only update the "rating" if we have no rating yet locally
            if love:
                if rating == 0: #works with float
                    self._db.set(track.entry, rhythmdb.PROP_RATING, 5.0)
                    changed=True
                    #print ">> Updating rating to 5.0"
                    
            if changed:
                #print ">> Committing change to database"
                self._db.commit()
                
        except Exception, e:
            print "!! Exception whilst updating track, msg=%s" % str(e)
            
        return True

gobject.type_register(Updater) #@UndefinedVariable

_=Updater()
